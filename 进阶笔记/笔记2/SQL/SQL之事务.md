SQL之事务：
	
事务： 一系列步骤的业务操作，被事务管理，原子性地完成或是失败

操作步骤是：
	
	1.开启事务  start transaction;
	2.一系列增删改表中数据 步骤
	3.如果没问题：提交  commit;
	  如果有问题：回滚  rollback;
	-- 当执行完第三步后，我们可以认为是执行完了一条事务

事务的提交方式：1.自动提交 2. 手动提交
	
	1.mysql数据库中的事务默认是自动提交的，
		一条对表中数据的增删改语句会自动提交一次事务，
		不用开启事务,但是如果开启了事务，
		在事务中执行表中数据的增删改语句，那么则需要等待提交过后才会生效

	2.手动提交，则需要先开启事务，执行完后再手动提交。
	

	查看事务的默认提交方式：
		SELECT @@autocommit;   1：自动提交  0：手动提交
	修改事务的默认提交方式：
		SET @@autocommit = 1;
	
事务的四大特征：
	
	1.原子性：操作不可分割
	2.持久性：数据持久
	3.隔离性：事务间不互相影响
	4.一致性：数据总量是一致的，不凭空消失

事务间本该具备独立性，但是现实中往往出现交叉，产生一些问题：脏读、不可重复读、幻读。


	1. 脏读 ：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
	
	2. 不可重复读 ：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。

	3. 幻读 : 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。


隔离级别：

	1. read uncommitted :读未提交
		（-- 出现脏读问题： 
		
		行为特点：
		在A事务提交前，其修改的数据能被B事务即时读取到）

	2. read committed:读已提交
		 (-- 解决了脏读问题，但是出现
			不可重复读问题：同一事务内读取的内容不一致
			
		行为特点：
		在A事务提交前后，B事务读取的内容不一致:
		B事务在A提交前读不到更新内容，
		在A事务提交后可即时读取到更新)

	3. repeatable read:可重复读(mysql默认)
		（-- 解决了不可重复读问题，但是
			 产生幻读问题：
				当A事务修改所有数据条内容时，
				B事务增加一个数据，
				A事务不能看见"所有的数据条被修改"		
			
		行为特点：
		在A事务提交前后，B事务读取的内容不一致，
		如果A事务提交后，B事务在自身事务提交前读不到
		更新内容，提交后可读取到更新)
	
	4. serializable:串行化	
		（通过类似java synchronize(object)的方式加锁的方式，
			解决了幻读问题,阻塞B事务的修改）

查看和设置隔离级别：
	
	查看：SELECT @@transaction_isolation;	
	设置：SET GLOBAL TRANSACTION ISOLATION level 级别字符串；
			级别字符串：
				read uncommitted :读未提交
				read committed:读已提交
				repeatable read:可重复读
				serializable:串行化	
