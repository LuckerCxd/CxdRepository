1.	static修饰的方法是类方法,绑定在类上,而实例方法是绑定在对象上的 
	static 不能用来修饰顶级类 ---->只有内部类才能用static来修饰
	那么 静态内部类  能实例化了吗? -->可以
	静态类 并不意味着就不能被实例化,
		不使用static修饰的内部类,其对象是依赖于外部类对象的,
			就是说只有在外部类对象存在的情况下,再利用外部类对象去new内部类对象这个操作才是合理的
			当内部类用public/protected修饰时:
				因此它的new 使用应该为:
					Outer xxx1 = new Outer(par1,par2,....);
					Outer.NoStaticInner xxx1_x = xxx1.new NoStaticInner(par1,par2,...)
			当内部类用private修饰时:
				这里是不能在main中创建的,因此,它的产生要由外部类对象来创建
		而静态内部类是为了让内部类对象不依赖于外部类对象,
			当静态内部类用public/protected修饰时:
				就是说在外部类对象未创建时,内部类对象可以被外部类new出来,注意:外部类不是外部类对象
				注意:
				因此它的new 使用在main时应该为:
					Outer.StaticInner xxx1_x =new Outer.StaticInner(par1,par2,...)
			当静态内部类用private修饰时:
				这里是不能在main中创建的,因此,它的产生要由外部类对象来创建,即便不依赖于外部类对象存在

2.("普通内部类" 在这里被定义为: 无static修饰的内部类)
	外部类与内部类的关联:
		1.外部类对象可以访问普通内部类的成员,调用普通内部类的方法,(二者是绑定的),反过来也一样.
			它们二者在同一个类下,根本就无关于权限的问题,即便是private,它们也是视若不见的
		2.外部类对象可以访问静态内部类成员,调用静态内部类方法
			然而,静态内部类未绑定于外部类对象,因此,静态类内部类只能访问外部非实例对象或是方法(即外部类方法,类对象)
		在使用上:
			Outer.this.xxx   内部类访问外部类对象成员
		总结:
			外部类拥有内部类的所有权,而内部类只有当绑定了外部类对象时(即为普通内部类),外部类对象与内部类对象二者完全公开
				
	那么内部类结构的用途在于什么? 
		我的理解是:
			1.不管对于静态内部类还是普通内部类而言,目的都在于实现整体类的分类
				静态内部可以跨越外部类实现分类 <--->普通内部类可以是外部类对象的分类
				二者使用的场景是不一样的:
					如果一开始就已知类的分类情况,可以直接使用静态内部类创建对象
					如果是创建完,经过一系列处理验证到类的分类情况,就应该使用普通内部类
			2.普通内部类还可以当做类的组合来使用,可以在外部类对象下,创建很多个普通内部类作为组件
				但是,像这种情况应该使用类的组合来解决,使用内部类并不是一个优解,并不推荐
					
		
				
				
